#!/usr/bin/env node

// src/cli/bin.ts
import pc6 from "picocolors";

// src/index.ts
import { join as join2 } from "path";
import dotenv from "dotenv";
import { expect as jestExpect } from "expect";

// src/core/compiler/index.ts
import { mkdirSync, existsSync, writeFileSync } from "fs";
import { tmpdir } from "os";
import { join, resolve, basename } from "path";
import { build } from "esbuild";
var TestCompiler = class {
  cacheDir;
  defaultOptions = {
    format: "esm",
    platform: "node",
    target: "node18",
    sourcemap: true,
    bundle: true,
    external: [
      "shortest",
      "fs",
      "path",
      "os",
      "util",
      "events",
      "stream",
      "assert",
      "url",
      "crypto",
      "buffer",
      "querystring",
      "fsevents"
    ],
    banner: {
      js: `
        import { fileURLToPath } from 'url';
        import { dirname } from 'path';
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = dirname(__filename);
        import { createRequire } from "module";
        const require = createRequire(import.meta.url);
      `
    }
  };
  constructor() {
    this.cacheDir = join(tmpdir(), "shortest-cache");
    if (!existsSync(this.cacheDir)) {
      mkdirSync(this.cacheDir, { recursive: true });
    }
  }
  async compileFile(filePath) {
    const fileName = basename(filePath).replace(".ts", ".mjs");
    const outputPath = join(this.cacheDir, fileName);
    const packageJson = {
      type: "module",
      imports: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      }
    };
    writeFileSync(
      join(this.cacheDir, "package.json"),
      JSON.stringify(packageJson)
    );
    await build({
      ...this.defaultOptions,
      entryPoints: [filePath],
      outfile: outputPath,
      alias: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      },
      resolveExtensions: [".ts", ".js", ".mjs"],
      banner: {
        js: 'import { createRequire } from "module";const require = createRequire(import.meta.url);'
      }
    });
    return outputPath;
  }
  async loadModule(filePath, cwd) {
    const absolutePath = resolve(cwd, filePath);
    if (!existsSync(absolutePath)) {
      throw new Error(`Config file not found: ${filePath}`);
    }
    try {
      const result = await build({
        ...this.defaultOptions,
        entryPoints: [absolutePath],
        write: false,
        external: ["shortest"]
      });
      const code = result.outputFiles[0].text;
      const tempFile = join(this.cacheDir, "config.mjs");
      writeFileSync(tempFile, code);
      return import(`file://${tempFile}`);
    } catch (error) {
      throw new Error(`Failed to load config from ${absolutePath}: ${error}`);
    }
  }
};

// src/index.ts
var globalConfig = null;
var compiler = new TestCompiler();
if (!global.__shortest__) {
  global.__shortest__ = {
    expect: jestExpect,
    registry: {
      tests: /* @__PURE__ */ new Map(),
      currentFileTests: [],
      beforeAllFns: [],
      afterAllFns: [],
      beforeEachFns: [],
      afterEachFns: [],
      directTestCounter: 0
    }
  };
  global.expect = global.__shortest__.expect;
  dotenv.config({ path: join2(process.cwd(), ".env") });
  dotenv.config({ path: join2(process.cwd(), ".env.local") });
}
function validateConfig(config) {
  const missingFields = [];
  if (config.headless === void 0)
    missingFields.push("headless");
  if (!config.baseUrl)
    missingFields.push("baseUrl");
  if (!config.testPattern)
    missingFields.push("testPattern");
  if (!config.anthropicKey && !process.env.ANTHROPIC_API_KEY)
    missingFields.push("anthropicKey");
  if (missingFields.length > 0) {
    throw new Error(
      `Missing required fields in shortest.config.ts:
` + missingFields.map((field) => `  - ${field}`).join("\n")
    );
  }
}
async function initialize() {
  if (globalConfig)
    return globalConfig;
  dotenv.config({ path: join2(process.cwd(), ".env") });
  dotenv.config({ path: join2(process.cwd(), ".env.local") });
  const configFiles = [
    "shortest.config.ts",
    "shortest.config.js",
    "shortest.config.mjs"
  ];
  for (const file of configFiles) {
    try {
      const module = await compiler.loadModule(file, process.cwd());
      if (module.default) {
        const config = module.default;
        validateConfig(config);
        globalConfig = {
          ...config,
          anthropicKey: process.env.ANTHROPIC_API_KEY || config.anthropicKey
        };
        return globalConfig;
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Config Error: ${error.message}`);
      }
      continue;
    }
  }
  throw new Error(
    "No config file found. Create shortest.config.ts in your project root.\nRequired fields:\n  - headless: boolean\n  - baseUrl: string\n  - testPattern: string\n  - anthropicKey: string"
  );
}
function getConfig() {
  if (!globalConfig) {
    throw new Error("Config not initialized. Call initialize() first");
  }
  return globalConfig;
}
function createTestChain(nameOrFn, payloadOrFn, fn) {
  const registry = global.__shortest__.registry;
  if (Array.isArray(nameOrFn)) {
    const tests = nameOrFn.map((name) => {
      const test3 = {
        name,
        expectations: []
      };
      registry.tests.set(name, [...registry.tests.get(name) || [], test3]);
      registry.currentFileTests.push(test3);
      return test3;
    });
    const lastTest = tests[tests.length - 1];
    if (!lastTest.name) {
      throw new Error("Test name is required");
    }
    return createTestChain(lastTest.name, payloadOrFn, fn);
  }
  if (typeof nameOrFn === "function") {
    registry.directTestCounter++;
    const test3 = {
      name: `Direct Test #${registry.directTestCounter}`,
      directExecution: true,
      fn: nameOrFn
    };
    registry.currentFileTests.push(test3);
    return {
      expect: () => {
        throw new Error("expect() cannot be called on direct execution test");
      },
      after: () => {
        throw new Error("after() cannot be called on direct execution test");
      },
      before: () => {
        throw new Error("before() cannot be called on direct execution test");
      }
    };
  }
  const test2 = {
    name: nameOrFn,
    payload: typeof payloadOrFn === "function" ? void 0 : payloadOrFn,
    fn: typeof payloadOrFn === "function" ? payloadOrFn : fn,
    expectations: []
  };
  registry.tests.set(nameOrFn, [...registry.tests.get(nameOrFn) || [], test2]);
  registry.currentFileTests.push(test2);
  const chain = {
    expect(descriptionOrFn, payloadOrFn2, fn2) {
      if (typeof descriptionOrFn === "function") {
        test2.expectations = test2.expectations || [];
        test2.expectations.push({
          directExecution: true,
          fn: descriptionOrFn
        });
        return chain;
      }
      test2.expectations = test2.expectations || [];
      test2.expectations.push({
        description: descriptionOrFn,
        payload: typeof payloadOrFn2 === "function" ? void 0 : payloadOrFn2,
        fn: typeof payloadOrFn2 === "function" ? payloadOrFn2 : fn2
      });
      return chain;
    },
    before(fn2) {
      test2.beforeFn = (context) => Promise.resolve(fn2(context));
      return chain;
    },
    after(fn2) {
      test2.afterFn = (context) => Promise.resolve(fn2(context));
      return chain;
    }
  };
  return chain;
}
var test = Object.assign(
  (nameOrFn, payloadOrFn, fn) => createTestChain(nameOrFn, payloadOrFn, fn),
  {
    beforeAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeAllFns.push(hook);
    },
    afterAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterAllFns.push(hook);
    },
    beforeEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeEachFns.push(hook);
    },
    afterEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterEachFns.push(hook);
    }
  }
);

// src/browser/integrations/github.ts
import dotenv2 from "dotenv";
import { authenticator } from "otplib";
var GitHubTool = class {
  totpSecret;
  selectors = {
    loginForm: "#login form",
    usernameInput: "#login_field",
    passwordInput: "#password",
    submitButton: '[type="submit"]',
    useAuthenticatorButton: 'button:has-text("Use authenticator")',
    useAuthenticatorLink: '[data-test-selector="totp-app-link"]',
    otpInput: "#app_totp",
    errorMessage: ".flash-error"
  };
  constructor(secret) {
    dotenv2.config({ path: [".env", ".env.local"] });
    this.totpSecret = secret || process.env.GITHUB_TOTP_SECRET || "";
    if (!this.totpSecret) {
      throw new Error(
        "GITHUB_TOTP_SECRET is required in .env file or via --secret flag"
      );
    }
  }
  validateSecret() {
    if (!this.totpSecret) {
      throw new Error(
        "GITHUB_TOTP_SECRET is required in .env file or via --secret flag"
      );
    }
  }
  generateTOTPCode() {
    this.validateSecret();
    try {
      const code = authenticator.generate(this.totpSecret);
      const timeRemaining = authenticator.timeRemaining();
      return { code, timeRemaining };
    } catch (error) {
      throw new Error(`Failed to generate TOTP code: ${error}`);
    }
  }
  async GithubLogin(browserTool, credentials) {
    try {
      await browserTool.waitForSelector(this.selectors.loginForm, {
        timeout: 1e4
      });
      await browserTool.fill(
        this.selectors.usernameInput,
        credentials.username
      );
      await browserTool.fill(
        this.selectors.passwordInput,
        credentials.password
      );
      await browserTool.click(this.selectors.submitButton);
      try {
        await browserTool.waitForSelector(
          this.selectors.useAuthenticatorButton,
          { timeout: 5e3 }
        );
        await browserTool.click(this.selectors.useAuthenticatorButton);
      } catch {
        await browserTool.waitForSelector(this.selectors.useAuthenticatorLink, {
          timeout: 5e3
        });
        await browserTool.click(this.selectors.useAuthenticatorLink);
      }
      await browserTool.waitForSelector(this.selectors.otpInput, {
        timeout: 1e3
      });
      const { code } = this.generateTOTPCode();
      await browserTool.fill(this.selectors.otpInput, code);
      const navigationPromise = browserTool.waitForNavigation({
        timeout: 3e3
      });
      await browserTool.press(this.selectors.otpInput, "Enter");
      await navigationPromise;
      const isLoggedIn = await browserTool.findElement(this.selectors.loginForm) === null;
      return {
        success: isLoggedIn,
        error: isLoggedIn ? void 0 : "Failed to verify login success"
      };
    } catch (error) {
      try {
        const currentUrl = await browserTool.getPage().url();
        if (!currentUrl.includes("github.com")) {
          return {
            success: true
          };
        }
      } catch {
      }
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error during GitHub login"
      };
    }
  }
};

// src/core/runner/index.ts
import { pathToFileURL } from "url";
import { glob } from "glob";
import pc5 from "picocolors";
import * as playwright from "playwright";
import { request } from "playwright";

// src/ai/client.ts
import Anthropic from "@anthropic-ai/sdk";
import pc from "picocolors";

// src/browser/core/bash-tool.ts
import { spawn } from "child_process";
var BashTool = class {
  async execute(command) {
    return new Promise((resolve2, reject) => {
      const child = spawn(command, { shell: true });
      let output = "";
      let errorOutput = "";
      child.stdout.on("data", (data) => {
        output += data.toString();
      });
      child.stderr.on("data", (data) => {
        errorOutput += data.toString();
        if (this.getErrorType(data.toString()) === "timeout") {
          console.log("Timeout error occurred, retrying...");
        }
      });
      child.on("exit", (code) => {
        if (code === 0) {
          resolve2(output.trim());
        } else {
          resolve2(
            errorOutput.trim() || `Process exited with code ${code ? code.toString() : "unknown"}`
          );
        }
      });
      child.on("error", (err) => {
        reject(`Error spawning process: ${err.message}`);
        throw err;
      });
    });
  }
  /**
   * Check the type of error from the provided stderr buffer
   * @param data Linux / PowerShell stderr buffer
   * @returns The type of error (e.g., "timeout", "network", etc)
   */
  getErrorType(data) {
    const unauthorizedRegex = /401 Unauthorized/i;
    if (unauthorizedRegex.test(data)) {
      return "unauthorized";
    }
    const timeoutRegex = /timeout|retrying in|request timed out/i;
    if (timeoutRegex.test(data)) {
      return "timeout";
    }
    const networkErrorRegex = /Could not resolve host|Name or service not known|connection refused|ENOTFOUND/i;
    if (networkErrorRegex.test(data)) {
      return "network";
    }
    return "unknown";
  }
};

// src/ai/prompts/index.ts
import os from "os";
var SYSTEM_PROMPT = `You are a test automation expert working with a Chrome browser. You will be given test instructions, and your task is to execute specified browser actions to validate the provided test cases. You are already in the Chrome browser and on the relevant application page, so there is no need to open or initialize the browser yourself.

EXAMPLE TEST CASE:
------------------
Test: "Log in to the app using GitHub login"
Context: {"username":"argo.mohrad@gmail.com","password":"password1234"}
Callback function: [NO_CALLBACK]
Expect: 1. Test case to be generated within at least 20 seconds [HAS_CALLBACK]
------------------

IMPORTANT GLOBAL RULES:

1. **Waiting for Conditions**:
   - Always wait for the tool to finish before proceeding to the next action. You will recieve a message to continue with your next action once the wait is over. Then validate the condition is met.

2. **Tool Usage**:
   - You may need to use provided tools to perform certain actions (e.g., clicking, navigating, or running callbacks).
   - After invoking a tool, wait until the tool finishes its execution and you receive a success/failure result.
   - You will also receive metadata about the tool's execution to help you interpret its outcome.
   - Only after the tool finishes and you know the result should you request any screenshots or proceed to the next action.

3. **Screenshot Rule**:
   - Do not request screenshots until after a tool has completely finished its execution.
   - Once the tool execution result is received, you may then request a screenshot to determine subsequent actions if needed.

4. **GitHub Login Flow with 2FA**:
   - If you need to test a GitHub login flow that involves 2FA, only call the "github_login" tool after you have confirmed that the GitHub login page is displayed.
   - Calling the "github_login" tool prematurely (before the GitHub login page is visible) will lead to incorrect test behavior.

5. **Callbacks**:
   - Steps may include a notation like [HAS_CALLBACK], which means after completing the browser actions for that step, you must call the "run_callback" tool.

6. **Navigation Rule**:
   - Only use the "navigate" tool when explicitly specified in the test case instructions.
   - Do not use navigation based on intuition - follow test instructions exactly.
   - You must use the "navigate" tool as you don't have direct access to the browser search bar.
   - After navigation, verify the requested page is loaded by checking the URL in the metadata.

7. **Test Expectations**:
   - All expectations listed in the test instructions must be fulfilled.
   - If any expectation is not met, the test case must be marked as failed.

8. **Testing Email**:
   - If you need to test a condition that involves checking the contents of an email, use the "check_email" tool.
   - If no email address is given to you for this test, you must fail the test.
   - You MUST pass the email address that is given to you to the tool as a parameter, otherwise it will fail.
   - For email validation, you MUST always use 'Click' and 'Mouse' actions instead of keyboard shortcuts.

9. **Bash Commands**:
   - You have access to a bash tool to execute bash commands.
   - Only use tools typically available in a bash terminal, unless the prompt specifically instructs otherwise
   - When generating bash commands, ensure they are appropriate for the operating system you are currently using: ${os.platform()}.
   - If you are asked to generate bash command for API requests, you should make sure you replace placeholders (<>) in the request details with the actual values from memory or context.

Your task is to:
1. Execute browser actions to validate test cases
2. Use provided browser tools to interact with the page
3. Return test execution results in strict JSON format: { result: "pass" | "fail", reason: string }.
   For failures, provide a maximum 1-sentence reason.
   IMPORTANT:
   - DO NOT include anything else in your response, only the result and reason.
   - DO NOT include any other JSON-like object in your response except the required structure.
   - If there's need to do that, remove braces {} to ensure it's not interpreted as JSON.
4. For click actions, provide x,y coordinates of the element to click.`;

// src/ai/tools/index.ts
var AITools = [
  {
    type: "computer_20241022",
    name: "computer",
    display_width_px: 1920,
    display_height_px: 1080,
    display_number: 1
  },
  {
    name: "github_login",
    description: "Handle GitHub OAuth login with 2FA",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["github_login"],
          description: "The action to perform. It's always equal to 'github_login'"
        },
        username: {
          type: "string",
          description: "GitHub username or email"
        },
        password: {
          type: "string",
          description: "GitHub password"
        }
      },
      required: ["action", "username", "password"]
    }
  },
  {
    name: "check_email",
    description: "View received email in new browser tab",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["check_email"],
          description: "Check that the email was received with specified content in a new tab"
        }
      },
      required: ["action", "email"]
    }
  },
  {
    name: "sleep",
    description: "Pause test execution for specified duration",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["sleep"],
          description: "The action to perform"
        },
        duration: {
          type: "number",
          description: "Duration to sleep in milliseconds (e.g. 5000 for 5 seconds)",
          minimum: 0,
          maximum: 6e4
        }
      },
      required: ["action", "duration"]
    }
  },
  {
    name: "run_callback",
    description: "Run callback function for current test step",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["run_callback"],
          description: "Execute callback for current step"
        }
      },
      required: ["action"]
    }
  },
  {
    name: "navigate",
    description: "Navigate to URLs in new browser tabs",
    input_schema: {
      type: "object",
      properties: {
        action: {
          type: "string",
          enum: ["navigate"],
          description: "The action to perform"
        },
        url: {
          type: "string",
          description: "The URL to navigate to"
        }
      },
      required: ["action", "url"]
    }
  },
  {
    type: "bash_20241022",
    name: "bash"
  }
];

// src/ai/client.ts
var AIClient = class {
  client;
  model;
  maxMessages;
  debugMode;
  constructor(config, debugMode = false) {
    if (!config.apiKey) {
      throw new Error(
        "Anthropic API key is required. Set it in shortest.config.ts or ANTHROPIC_API_KEY env var"
      );
    }
    this.client = new Anthropic({
      apiKey: config.apiKey
    });
    this.model = "claude-3-5-sonnet-20241022";
    this.maxMessages = 10;
    this.debugMode = debugMode;
  }
  async processAction(prompt, browserTool, outputCallback, toolOutputCallback) {
    const maxRetries = 3;
    let attempts = 0;
    while (attempts < maxRetries) {
      try {
        return await this.makeRequest(
          prompt,
          browserTool,
          outputCallback,
          toolOutputCallback
        );
      } catch (error) {
        attempts++;
        if (attempts === maxRetries)
          throw error;
        console.log(`  Retry attempt ${attempts}/${maxRetries}`);
        await new Promise((r) => setTimeout(r, 5e3 * attempts));
      }
    }
    return {
      finalResponse: null,
      tokenUsage: { input: 0, output: 0 },
      pendingCache: null
    };
  }
  async makeRequest(prompt, browserTool, _outputCallback, _toolOutputCallback) {
    const messages = [];
    const pendingCache = {};
    if (this.debugMode) {
      console.log(pc.cyan("\n\u{1F916} Prompt:"), pc.dim(prompt));
    }
    messages.push({
      role: "user",
      content: prompt
    });
    while (true) {
      try {
        await new Promise((resolve2) => setTimeout(resolve2, 1e3));
        const response = await this.client.beta.messages.create({
          model: this.model,
          max_tokens: 1024,
          messages,
          system: SYSTEM_PROMPT,
          tools: [...AITools],
          betas: ["computer-use-2024-10-22"]
        });
        const tokenUsage = {
          input: response.usage.input_tokens,
          output: response.usage.output_tokens
        };
        if (this.debugMode) {
          response.content.forEach((block) => {
            if (block.type === "text") {
              console.log(pc.green("\n\u{1F916} AI:"), pc.dim(block.text));
            } else if (block.type === "tool_use") {
              const toolBlock = block;
              console.log(pc.yellow("\n\u{1F527} Tool Request:"), {
                tool: toolBlock.name,
                input: toolBlock.input
              });
            }
          });
        }
        messages.push({
          role: "assistant",
          content: response.content
        });
        const toolRequests = response.content.filter(
          (block) => block.type === "tool_use"
        );
        if (toolRequests.length > 0) {
          const toolResults = await Promise.all(
            toolRequests.map(async (toolRequest) => {
              switch (toolRequest.name) {
                case "bash":
                  try {
                    const toolResult = await new BashTool().execute(
                      toolRequest.input.command
                    );
                    return { toolRequest, toolResult };
                  } catch (error) {
                    console.error("Error executing bash command:", error);
                    throw error;
                  }
                default:
                  try {
                    const toolResult = await browserTool.execute(
                      toolRequest.input
                    );
                    let extras = {};
                    if (toolRequest.input.coordinate) {
                      const [x, y] = toolRequest.input.coordinate;
                      const componentStr = await browserTool.getNormalizedComponentStringByCoords(
                        x,
                        y
                      );
                      extras = { componentStr };
                    }
                    pendingCache.steps = [
                      ...pendingCache.steps || [],
                      {
                        action: toolRequest,
                        reasoning: toolResult.output || "",
                        result: toolResult.output || null,
                        extras,
                        timestamp: Date.now()
                      }
                    ];
                    return { toolRequest, toolResult };
                  } catch (error) {
                    console.error("Error executing browser tool:", error);
                    throw error;
                  }
              }
            })
          );
          toolResults.forEach((result) => {
            if (result) {
              const { toolRequest, toolResult } = result;
              switch (toolRequest.name) {
                case "bash":
                  messages.push({
                    role: "user",
                    content: [
                      {
                        type: "tool_result",
                        tool_use_id: toolRequest.id,
                        content: [
                          {
                            type: "text",
                            text: JSON.stringify(toolResult)
                          }
                        ]
                      }
                    ]
                  });
                  break;
                default:
                  messages.push({
                    role: "user",
                    content: [
                      {
                        type: "tool_result",
                        tool_use_id: toolRequest.id,
                        content: toolResult.base64_image ? [
                          {
                            type: "image",
                            source: {
                              type: "base64",
                              media_type: "image/jpeg",
                              data: toolResult.base64_image
                            }
                          }
                        ] : [
                          {
                            type: "text",
                            text: toolResult.output || ""
                          }
                        ]
                      }
                    ]
                  });
              }
            }
          });
        } else {
          return {
            messages,
            finalResponse: response,
            pendingCache,
            tokenUsage
          };
        }
      } catch (error) {
        if (error.message?.includes("rate_limit")) {
          console.log("\u23F3 Rate limited, waiting 60s...");
          await new Promise((resolve2) => setTimeout(resolve2, 6e4));
          continue;
        }
        throw error;
      }
    }
  }
};

// src/browser/core/browser-tool.ts
import {
  writeFileSync as writeFileSync2,
  mkdirSync as mkdirSync2,
  readdirSync,
  statSync,
  unlinkSync
} from "fs";
import { join as join3 } from "path";
import pc2 from "picocolors";

// src/types/test.ts
var CallbackError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CallbackError";
  }
};
var AssertionCallbackError = class extends CallbackError {
  constructor(message, actual, expected) {
    super(message);
    this.actual = actual;
    this.expected = expected;
    this.name = "AssertionCallbackError";
  }
};

// src/browser/core/index.ts
var ToolError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ToolError";
  }
};
var BaseBrowserTool = class {
  width;
  height;
  displayNum;
  screenshotDelay;
  toolType = "computer_20241022";
  toolName = "computer";
  constructor(options) {
    this.width = options.width;
    this.height = options.height;
    this.displayNum = options.displayNum || 1;
    this.screenshotDelay = options.screenshotDelay || 2e3;
  }
  validateCoordinates(x, y) {
    if (x < 0 || x > this.width || y < 0 || y > this.height) {
      throw new ToolError(`Coordinates (${x}, ${y}) out of bounds`);
    }
  }
  formatToolResult(output, error, base64_image, metadata) {
    return {
      output,
      error,
      base64_image,
      metadata
    };
  }
};

// src/browser/actions/index.ts
var keyboardShortcuts = {
  "ctrl+l": ["Control", "l"],
  "ctrl+a": ["Control", "a"],
  "ctrl+c": ["Control", "c"],
  "ctrl+v": ["Control", "v"],
  "alt+tab": ["Alt", "Tab"],
  return: ["Enter"],
  enter: ["Enter"],
  esc: ["Escape"],
  tab: ["Tab"],
  delete: ["Delete"],
  backspace: ["Backspace"],
  space: [" "],
  arrowup: ["ArrowUp"],
  arrowdown: ["ArrowDown"],
  arrowleft: ["ArrowLeft"],
  arrowright: ["ArrowRight"],
  page_down: ["PageDown"],
  page_up: ["PageUp"]
};
var scaleRatio = {
  x: 1543 / 1170,
  y: 32 / 24
};
async function mouseMove(page, x, y) {
  if (!Number.isInteger(x) || !Number.isInteger(y) || x < 0 || y < 0) {
    throw new ToolError("Coordinates must be non-negative integers");
  }
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await page.mouse.move(scaledX, scaledY);
  await page.evaluate(
    ({ x: x2, y: y2 }) => {
      const cursor = document.getElementById("ai-cursor");
      const trail = document.getElementById("ai-cursor-trail");
      if (cursor && trail) {
        window.cursorPosition = { x: x2, y: y2 };
        cursor.style.left = `${x2}px`;
        cursor.style.top = `${y2}px`;
        setTimeout(() => {
          trail.style.left = `${x2}px`;
          trail.style.top = `${y2}px`;
        }, 50);
      }
    },
    { x: scaledX, y: scaledY }
  );
  await page.waitForTimeout(50);
}
async function click(page, x, y) {
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await mouseMove(page, x, y);
  await page.mouse.click(scaledX, scaledY);
  await showClickAnimation(page, "left");
}
async function dragMouse(page, x, y) {
  const scaledX = Math.round(x * scaleRatio.x);
  const scaledY = Math.round(y * scaleRatio.y);
  await page.mouse.down();
  await page.mouse.move(scaledX, scaledY);
  await page.mouse.up();
}
async function showClickAnimation(page, type = "left") {
  await page.evaluate((clickType) => {
    const cursor = document.getElementById("ai-cursor");
    if (cursor) {
      cursor.classList.add("clicking");
      switch (clickType) {
        case "double":
          cursor.style.transform = "translate(-50%, -50%) scale(0.7)";
          cursor.style.backgroundColor = "rgba(255, 0, 0, 0.5)";
          break;
        case "right":
          cursor.style.borderColor = "blue";
          break;
        default:
          cursor.style.transform = "translate(-50%, -50%) scale(0.8)";
      }
      setTimeout(() => {
        cursor.classList.remove("clicking");
        cursor.style.transform = "translate(-50%, -50%) scale(1)";
        cursor.style.backgroundColor = "rgba(255, 0, 0, 0.2)";
        cursor.style.borderColor = "red";
      }, 200);
    }
  }, type);
}
async function getCursorPosition(page) {
  const position = await page.evaluate(() => {
    return window.cursorPosition || { x: 0, y: 0 };
  });
  return [position.x, position.y];
}

// src/browser/integrations/mailosaur.ts
import Mailosaur from "mailosaur";
var MailosaurTool = class {
  client;
  serverId;
  emailAddress;
  constructor(config) {
    this.client = new Mailosaur(config.apiKey);
    this.serverId = config.serverId;
    this.emailAddress = config.emailAddress;
  }
  async getLatestEmail() {
    try {
      const message = await this.client.messages.get(this.serverId, {
        sentTo: this.emailAddress
      });
      if (!message.html?.body || !message.text?.body) {
        throw new ToolError("Email content missing");
      }
      return {
        subject: message.subject || "No Subject",
        html: message.html.body,
        text: message.text.body
      };
    } catch (error) {
      throw new ToolError(`Mailosaur API error: ${error}`);
    }
  }
};

// src/browser/core/browser-tool.ts
var BrowserTool = class extends BaseBrowserTool {
  page;
  browserManager;
  toolType = "computer_20241022";
  toolName = "computer";
  screenshotDir;
  cursorVisible = true;
  lastMousePosition = [0, 0];
  githubTool;
  viewport;
  testContext;
  MAX_SCREENSHOTS = 10;
  MAX_AGE_HOURS = 5;
  mailosaurTool;
  config;
  constructor(page, browserManager, config) {
    super(config);
    this.page = page;
    this.browserManager = browserManager;
    this.screenshotDir = join3(process.cwd(), ".shortest", "screenshots");
    mkdirSync2(this.screenshotDir, { recursive: true });
    this.viewport = { width: config.width, height: config.height };
    this.testContext = config.testContext;
    this.page.context().on("page", async (newPage) => {
      await newPage.waitForLoadState("domcontentloaded").catch(() => {
      });
      this.page = newPage;
    });
    this.initialize();
    this.cleanupScreenshots();
  }
  async initialize() {
    await initialize();
    this.config = getConfig();
    const initWithRetry = async () => {
      for (let i = 0; i < 3; i++) {
        try {
          await this.initializeCursor();
          break;
        } catch (error) {
          console.warn(
            `Retry ${i + 1}/3: Cursor initialization failed:`,
            error
          );
          await new Promise((resolve2) => setTimeout(resolve2, 100));
        }
      }
    };
    await initWithRetry();
    this.page.on("load", async () => {
      await initWithRetry();
    });
  }
  async initializeCursor() {
    try {
      await this.page.waitForLoadState("domcontentloaded", { timeout: 1e3 }).catch(() => {
      });
      const hasStyles = await this.page.evaluate(() => {
        return !!document.querySelector("style[data-shortest-cursor]");
      }).catch(() => false);
      if (!hasStyles) {
        await this.page.evaluate(() => {
          const style = document.createElement("style");
          style.setAttribute("data-shortest-cursor", "true");
          style.textContent = `
            #ai-cursor {
              width: 20px;
              height: 20px;
              border: 2px solid red;
              border-radius: 50%;
              position: fixed;
              pointer-events: none;
              z-index: 999999;
              transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
              transform: translate(-50%, -50%);
              background-color: rgba(255, 0, 0, 0.2);
            }
            #ai-cursor.clicking {
              transform: translate(-50%, -50%) scale(0.8);
              background-color: rgba(255, 0, 0, 0.4);
            }
            #ai-cursor-trail {
              width: 8px;
              height: 8px;
              border-radius: 50%;
              position: fixed;
              pointer-events: none;
              z-index: 999998;
              background-color: rgba(255, 0, 0, 0.1);
              transition: all 0.1s linear;
              transform: translate(-50%, -50%);
            }
          `;
          document.head.appendChild(style);
        });
      }
      await this.page.evaluate(() => {
        if (!document.getElementById("ai-cursor")) {
          const cursor = document.createElement("div");
          cursor.id = "ai-cursor";
          document.body.appendChild(cursor);
          const trail = document.createElement("div");
          trail.id = "ai-cursor-trail";
          document.body.appendChild(trail);
          window.cursorPosition = window.cursorPosition || { x: 0, y: 0 };
          window.lastPosition = window.lastPosition || { x: 0, y: 0 };
          cursor.style.left = window.cursorPosition.x + "px";
          cursor.style.top = window.cursorPosition.y + "px";
          trail.style.left = window.cursorPosition.x + "px";
          trail.style.top = window.cursorPosition.y + "px";
          const updateCursor = (x, y) => {
            window.cursorPosition = { x, y };
            cursor.style.left = `${x}px`;
            cursor.style.top = `${y}px`;
            requestAnimationFrame(() => {
              trail.style.left = `${x}px`;
              trail.style.top = `${y}px`;
            });
          };
          document.addEventListener("mousemove", (e) => {
            window.lastPosition = window.cursorPosition;
            updateCursor(e.clientX, e.clientY);
          });
        }
      });
    } catch (error) {
      if (error instanceof Error && !error.message.includes("context was destroyed") && !error.message.includes("Target closed")) {
        console.warn("Cursor initialization failed:", error);
      }
    }
  }
  async click(selector) {
    await this.page.click(selector);
  }
  async clickAtCoordinates(x, y) {
    await click(this.page, x, y);
  }
  async execute(input) {
    try {
      let output = "";
      let metadata = {};
      switch (input.action) {
        case "left_click":
        case "right_click":
        case "middle_click":
        case "double_click": {
          const clickCoords = input.coordinates || this.lastMousePosition;
          await this.clickAtCoordinates(clickCoords[0], clickCoords[1]);
          output = `${input.action} at (${clickCoords[0]}, ${clickCoords[1]})`;
          metadata = await this.getMetadata();
          await this.page.waitForTimeout(100);
          if (await this.page.evaluate(() => document.readyState !== "complete").catch(() => true)) {
            try {
              await this.page.waitForLoadState("domcontentloaded", {
                timeout: 5e3
              });
              metadata = await this.getMetadata();
            } catch {
            }
          }
          break;
        }
        case "mouse_move":
          const coords = input.coordinates || input.coordinate;
          if (!coords) {
            throw new ToolError("Coordinates required for mouse_move");
          }
          await mouseMove(this.page, coords[0], coords[1]);
          this.lastMousePosition = [coords[0], coords[1]];
          output = `Mouse moved to (${coords[0]}, ${coords[1]})`;
          break;
        case "left_click_drag":
          if (!input.coordinates) {
            throw new ToolError("Coordinates required for left_click_drag");
          }
          await dragMouse(
            this.page,
            input.coordinates[0],
            input.coordinates[1]
          );
          output = `Dragged mouse to (${input.coordinates[0]}, ${input.coordinates[1]})`;
          break;
        case "cursor_position":
          const position = await getCursorPosition(this.page);
          output = `Cursor position: (${position[0]}, ${position[1]})`;
          break;
        case "screenshot":
          return await this.takeScreenshotWithMetadata();
        case "type":
          if (!input.text) {
            throw new ToolError("Text required for type action");
          }
          await this.page.waitForTimeout(100);
          await this.page.keyboard.type(input.text);
          await this.page.waitForTimeout(100);
          output = `Typed: ${input.text}`;
          break;
        case "key": {
          if (!input.text) {
            throw new ToolError("Key required for key action");
          }
          await this.page.waitForTimeout(100);
          const keyText = input.text.toLowerCase();
          const keys = Array.isArray(keyboardShortcuts[keyText]) ? keyboardShortcuts[keyText] : [keyboardShortcuts[keyText] || input.text];
          if (Array.isArray(keys)) {
            for (const key of keys) {
              await this.page.keyboard.down(key);
            }
            for (const key of [...keys].reverse()) {
              await this.page.keyboard.up(key);
            }
          } else {
            await this.page.keyboard.press(keys);
          }
          await this.page.waitForTimeout(100);
          output = `Pressed key: ${input.text}`;
          break;
        }
        case "github_login": {
          if (!this.githubTool) {
            this.githubTool = new GitHubTool();
          }
          const loginResult = await this.githubTool.GithubLogin(this, {
            username: input.username,
            password: input.password
          });
          output = loginResult.success ? "GitHub login was successfully completed" : `GitHub login failed: ${loginResult.error}`;
          break;
        }
        case "clear_session":
          const newContext = await this.browserManager.recreateContext();
          this.page = newContext.pages()[0] || await newContext.newPage();
          await this.page.evaluate(() => {
            localStorage.clear();
            sessionStorage.clear();
          });
          return {
            output: "Successfully cleared browser data and created new context",
            metadata: {}
          };
        case "run_callback": {
          if (!this.testContext?.currentTest) {
            throw new ToolError(
              "No test context available for callback execution"
            );
          }
          const testContext = this.testContext;
          const currentTest = testContext.currentTest;
          const currentStepIndex = testContext.currentStepIndex ?? 0;
          try {
            if (currentStepIndex === 0 && currentTest.fn) {
              await currentTest.fn(testContext);
              testContext.currentStepIndex = 1;
              return { output: "Test function executed successfully" };
            } else {
              const expectationIndex = currentStepIndex - 1;
              const expectation = currentTest.expectations?.[expectationIndex];
              if (expectation?.fn) {
                await expectation.fn(this.testContext);
                testContext.currentStepIndex = currentStepIndex + 1;
                return {
                  output: `Callback function for "${expectation.description}" passed successfully`
                };
              } else {
                return {
                  output: `Skipping callback execution: No callback function defined for expectation "${expectation?.description}"`
                };
              }
            }
          } catch (error) {
            if (error && error.matcherResult) {
              const assertionError = error;
              throw new AssertionCallbackError(
                assertionError.message,
                assertionError.matcherResult.actual,
                assertionError.matcherResult.expected
              );
            }
            throw new CallbackError(
              error instanceof Error ? error.message : String(error)
            );
          }
        }
        case "navigate": {
          if (!input.url) {
            throw new ToolError("URL required for navigation");
          }
          const newPage = await this.page.context().newPage();
          try {
            const navigationTimeout = 3e4;
            await newPage.goto(input.url, {
              timeout: navigationTimeout,
              waitUntil: "domcontentloaded"
            });
            await newPage.waitForLoadState("load", {
              timeout: 5e3
            }).catch((error) => {
              console.log("\u26A0\uFE0F Load timeout, continuing anyway", error);
            });
            this.page = newPage;
            output = `Navigated to ${input.url}`;
            metadata = {
              window_info: {
                url: input.url,
                title: await newPage.title(),
                size: this.page.viewportSize() || {
                  width: this.width,
                  height: this.height
                }
              }
            };
            break;
          } catch (error) {
            await newPage.close();
            throw new ToolError(`Navigation failed: ${error}`);
          }
        }
        case "sleep": {
          const defaultDuration = 1e3;
          const maxDuration = 6e4;
          let duration = input.duration ?? defaultDuration;
          if (duration > maxDuration) {
            console.warn(
              `Requested sleep duration ${duration}ms exceeds maximum of ${maxDuration}ms. Using maximum.`
            );
            duration = maxDuration;
          }
          const seconds = Math.round(duration / 1e3);
          console.log(
            `\u23F3 Waiting for ${seconds} second${seconds !== 1 ? "s" : ""}...`
          );
          await this.page.waitForTimeout(duration);
          output = `Finished waiting for ${seconds} second${seconds !== 1 ? "s" : ""}`;
          break;
        }
        case "check_email": {
          if (!this.mailosaurTool) {
            const mailosaurAPIKey = this.config.mailosaur?.apiKey || process.env.MAILOSAUR_API_KEY;
            const mailosaurServerId = this.config.mailosaur?.serverId || process.env.MAILOSAUR_SERVER_ID;
            if (!mailosaurAPIKey) {
              return {
                output: "Mailosaur API key is required",
                error: "MAILOSAUR_CONFIG_ERROR"
              };
            }
            if (!mailosaurServerId) {
              return {
                output: "Mailosaur server ID is required",
                error: "MAILOSAUR_CONFIG_ERROR"
              };
            }
            if (!input.email) {
              return {
                output: "Mailosaur email address is required",
                error: "MAILOSAUR_CONFIG_ERROR"
              };
            }
            this.mailosaurTool = new MailosaurTool({
              apiKey: mailosaurAPIKey,
              serverId: mailosaurServerId,
              emailAddress: input.email
            });
          }
          const newPage = await this.page.context().newPage();
          try {
            const email = await this.mailosaurTool.getLatestEmail();
            await newPage.setContent(email.html, {
              waitUntil: "domcontentloaded"
            });
            await newPage.waitForLoadState("load", {
              timeout: 5e3
            }).catch((error) => {
              console.log("\u26A0\uFE0F Load timeout, continuing anyway", error);
            });
            this.page = newPage;
            output = `Email received successfully. Navigated to new tab to display email: ${email.subject}`;
            metadata = {
              window_info: {
                title: email.subject,
                content: email.html,
                size: this.page.viewportSize() || {
                  width: this.width,
                  height: this.height
                }
              }
            };
            break;
          } catch (error) {
            await newPage.close();
            const errorMessage = error instanceof Error ? error.message : String(error);
            if (errorMessage.includes("Email content missing")) {
              return {
                output: `Email was found but content is missing. This might be due to malformed email. Moving to next test.`,
                error: "EMAIL_CONTENT_MISSING"
              };
            }
            if (errorMessage.includes("Mailosaur email address is required")) {
              return {
                output: `Email address is required but was not provided.`,
                error: "EMAIL_ADDRESS_MISSING"
              };
            }
            if (errorMessage.includes("No matching messages found")) {
              return {
                output: `No email found for ${input.email}. The email might not have been sent yet or is older than 1 hour. Moving to next test.`,
                error: "EMAIL_NOT_FOUND"
              };
            }
            return {
              output: `Failed to fetch or render email: ${errorMessage}. Moving to next test.`,
              error: "EMAIL_OPERATION_FAILED"
            };
          }
        }
        default:
          throw new ToolError(`Unknown action: ${input.action}`);
      }
      try {
        await this.page.waitForTimeout(200);
        metadata = await this.getMetadata();
      } catch (metadataError) {
        console.warn("Failed to get metadata:", metadataError);
        metadata = {};
      }
      return {
        output,
        metadata
      };
    } catch (error) {
      console.error(pc2.red("\n\u274C Browser Action Failed:"), error);
      if (error instanceof AssertionCallbackError) {
        return {
          output: `Assertion failed: ${error.message}${error.actual !== void 0 ? `
Expected: ${error.expected}
Received: ${error.actual}` : ""}`
        };
      }
      if (error instanceof CallbackError) {
        return {
          output: `Callback execution failed: ${error.message}`
        };
      }
      throw new ToolError(`Action failed: ${error}`);
    }
  }
  async getMetadata() {
    const metadata = {
      window_info: {},
      cursor_info: { position: [0, 0], visible: true }
    };
    try {
      let url;
      let title;
      try {
        url = await this.page.url();
      } catch {
        url = "navigating...";
      }
      try {
        title = await this.page.title();
      } catch {
        title = "loading...";
      }
      metadata.window_info = {
        url,
        title,
        size: this.page.viewportSize() || {
          width: this.width,
          height: this.height
        }
      };
      if (await this.isPageStable()) {
        const position = await getCursorPosition(this.page);
        metadata.cursor_info = {
          position,
          visible: this.cursorVisible
        };
      }
      return metadata;
    } catch (error) {
      console.warn("Failed to get metadata:", error);
      return metadata;
    }
  }
  async isPageStable() {
    try {
      return await this.page.evaluate(() => {
        return document.readyState === "complete" && !document.querySelector(".loading") && !document.querySelector(".cl-loading");
      }).catch(() => false);
    } catch {
      return false;
    }
  }
  async takeScreenshotWithMetadata() {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const filePath = join3(this.screenshotDir, `screenshot-${timestamp}.png`);
    const buffer = await this.page.screenshot({
      type: "jpeg",
      quality: 50,
      scale: "device",
      fullPage: false
    });
    writeFileSync2(filePath, buffer);
    console.log(`  Screenshot saved to: ${filePath}`);
    return {
      output: "Screenshot taken",
      base64_image: buffer.toString("base64"),
      metadata: await this.getMetadata()
    };
  }
  toToolParameters() {
    return {
      type: this.toolType,
      name: this.toolName,
      display_width_px: this.width,
      display_height_px: this.height,
      display_number: this.displayNum
    };
  }
  // Selector-based methods
  async waitForSelector(selector, options) {
    await this.page.waitForSelector(selector, options);
  }
  async fill(selector, value) {
    await this.page.fill(selector, value);
  }
  async press(selector, key) {
    await this.page.press(selector, key);
  }
  async findElement(selector) {
    return this.page.$(selector);
  }
  getPage() {
    return this.page;
  }
  async waitForNavigation(options) {
    await this.page.waitForLoadState("load", { timeout: options?.timeout });
  }
  updateTestContext(newContext) {
    this.testContext = newContext;
  }
  cleanupScreenshots() {
    try {
      const files = readdirSync(this.screenshotDir).filter((file) => file.endsWith(".png") || file.endsWith(".jpg")).map((file) => ({
        name: file,
        path: join3(this.screenshotDir, file),
        time: statSync(join3(this.screenshotDir, file)).mtime.getTime()
      })).sort((a, b) => b.time - a.time);
      const now = Date.now();
      const fiveHoursMs = this.MAX_AGE_HOURS * 60 * 60 * 1e3;
      files.forEach((file, index) => {
        const isOld = now - file.time > fiveHoursMs;
        const isBeyondLimit = index >= this.MAX_SCREENSHOTS;
        if (isOld || isBeyondLimit) {
          try {
            unlinkSync(file.path);
          } catch (error) {
            console.warn(`Failed to delete screenshot: ${file.path}`, error);
          }
        }
      });
    } catch (error) {
      console.warn("Failed to cleanup screenshots:", error);
    }
  }
  async showCursor() {
    this.cursorVisible = true;
    await this.page.evaluate(() => {
      const cursor = document.getElementById("ai-cursor");
      const trail = document.getElementById("ai-cursor-trail");
      if (cursor)
        cursor.style.display = "block";
      if (trail)
        trail.style.display = "block";
    });
  }
  async hideCursor() {
    this.cursorVisible = false;
    await this.page.evaluate(() => {
      const cursor = document.getElementById("ai-cursor");
      const trail = document.getElementById("ai-cursor-trail");
      if (cursor)
        cursor.style.display = "none";
      if (trail)
        trail.style.display = "none";
    });
  }
  /**
   * Retrieves normalized component string by X and Y coordinates
   * This is primarily used to determine change in UI
   * Playwright currently does not support such functionality
   * @see https://github.com/microsoft/playwright/issues/13273
   */
  async getNormalizedComponentStringByCoords(x, y) {
    return await this.getPage().evaluate(
      ({ x: x2, y: y2, allowedAttr }) => {
        const elem = document.elementFromPoint(x2, y2);
        if (elem) {
          let getDeepestChildNode2 = function(element) {
            let deepestChild = element.cloneNode(true);
            let maxDepth = 0;
            function traverse(node2, depth) {
              if (depth > maxDepth) {
                maxDepth = depth;
                deepestChild = node2;
              }
              Array.from(node2.children).forEach((child) => {
                traverse(child, depth + 1);
              });
            }
            traverse(deepestChild, 0);
            return deepestChild;
          }, cleanAttributesRecursively2 = function(element, options) {
            Array.from(element.attributes).forEach((attr) => {
              if (!options.exceptions.includes(attr.name)) {
                element.removeAttribute(attr.name);
              }
            });
            Array.from(element.children).forEach((child) => {
              cleanAttributesRecursively2(child, options);
            });
          };
          var getDeepestChildNode = getDeepestChildNode2, cleanAttributesRecursively = cleanAttributesRecursively2;
          const clone = elem.cloneNode(true);
          const deepestNode = getDeepestChildNode2(clone);
          const node = deepestNode.parentElement ? deepestNode.parentElement.parentElement ? deepestNode.parentElement.parentElement : deepestNode.parentElement : deepestNode;
          cleanAttributesRecursively2(node, {
            exceptions: allowedAttr
          });
          return node.outerHTML.trim().replace(/\s+/g, " ");
        } else {
          return "";
        }
      },
      {
        x,
        y,
        allowedAttr: [
          "type",
          "name",
          "placeholder",
          "aria-label",
          "role",
          "title",
          "alt",
          "d"
          // for <path> tags
        ]
      }
    );
  }
};

// src/browser/manager/index.ts
import { execSync } from "child_process";
import { URL } from "url";
import pc3 from "picocolors";
import { chromium } from "playwright";

// ../../node_modules/.pnpm/package-manager-detector@0.2.8/node_modules/package-manager-detector/dist/commands.mjs
function npmRun(agent) {
  return (args) => {
    if (args.length > 1) {
      return [agent, "run", args[0], "--", ...args.slice(1)];
    } else {
      return [agent, "run", args[0]];
    }
  };
}
function denoExecute() {
  return (args) => {
    return ["deno", "run", `npm:${args[0]}`, ...args.slice(1)];
  };
}
var npm = {
  "agent": ["npm", 0],
  "run": npmRun("npm"),
  "install": ["npm", "i", 0],
  "frozen": ["npm", "ci"],
  "global": ["npm", "i", "-g", 0],
  "add": ["npm", "i", 0],
  "upgrade": ["npm", "update", 0],
  "upgrade-interactive": null,
  "execute": ["npx", 0],
  "execute-local": ["npx", 0],
  "uninstall": ["npm", "uninstall", 0],
  "global_uninstall": ["npm", "uninstall", "-g", 0]
};
var yarn = {
  "agent": ["yarn", 0],
  "run": ["yarn", "run", 0],
  "install": ["yarn", "install", 0],
  "frozen": ["yarn", "install", "--frozen-lockfile"],
  "global": ["yarn", "global", "add", 0],
  "add": ["yarn", "add", 0],
  "upgrade": ["yarn", "upgrade", 0],
  "upgrade-interactive": ["yarn", "upgrade-interactive", 0],
  "execute": ["npx", 0],
  "execute-local": ["yarn", "exec", 0],
  "uninstall": ["yarn", "remove", 0],
  "global_uninstall": ["yarn", "global", "remove", 0]
};
var yarnBerry = {
  ...yarn,
  "frozen": ["yarn", "install", "--immutable"],
  "upgrade": ["yarn", "up", 0],
  "upgrade-interactive": ["yarn", "up", "-i", 0],
  "execute": ["yarn", "dlx", 0],
  "execute-local": ["yarn", "exec", 0],
  // Yarn 2+ removed 'global', see https://github.com/yarnpkg/berry/issues/821
  "global": ["npm", "i", "-g", 0],
  "global_uninstall": ["npm", "uninstall", "-g", 0]
};
var pnpm = {
  "agent": ["pnpm", 0],
  "run": ["pnpm", "run", 0],
  "install": ["pnpm", "i", 0],
  "frozen": ["pnpm", "i", "--frozen-lockfile"],
  "global": ["pnpm", "add", "-g", 0],
  "add": ["pnpm", "add", 0],
  "upgrade": ["pnpm", "update", 0],
  "upgrade-interactive": ["pnpm", "update", "-i", 0],
  "execute": ["pnpm", "dlx", 0],
  "execute-local": ["pnpm", "exec", 0],
  "uninstall": ["pnpm", "remove", 0],
  "global_uninstall": ["pnpm", "remove", "--global", 0]
};
var bun = {
  "agent": ["bun", 0],
  "run": ["bun", "run", 0],
  "install": ["bun", "install", 0],
  "frozen": ["bun", "install", "--frozen-lockfile"],
  "global": ["bun", "add", "-g", 0],
  "add": ["bun", "add", 0],
  "upgrade": ["bun", "update", 0],
  "upgrade-interactive": ["bun", "update", 0],
  "execute": ["bun", "x", 0],
  "execute-local": ["bun", "x", 0],
  "uninstall": ["bun", "remove", 0],
  "global_uninstall": ["bun", "remove", "-g", 0]
};
var deno = {
  "agent": ["deno", 0],
  "run": ["deno", "task", 0],
  "install": ["deno", "install", 0],
  "frozen": ["deno", "install", "--frozen"],
  "global": ["deno", "install", "-g", 0],
  "add": ["deno", "add", 0],
  "upgrade": ["deno", "outdated", "--update", 0],
  "upgrade-interactive": ["deno", "outdated", "--update", 0],
  "execute": denoExecute(),
  "execute-local": ["deno", "task", "--eval", 0],
  "uninstall": ["deno", "remove", 0],
  "global_uninstall": ["deno", "uninstall", "-g", 0]
};
var COMMANDS = {
  "npm": npm,
  "yarn": yarn,
  "yarn@berry": yarnBerry,
  "pnpm": pnpm,
  // pnpm v6.x or below
  "pnpm@6": {
    ...pnpm,
    run: npmRun("pnpm")
  },
  "bun": bun,
  "deno": deno
};
function resolveCommand(agent, command, args) {
  const value = COMMANDS[agent][command];
  return constructCommand(value, args);
}
function constructCommand(value, args) {
  if (value == null)
    return null;
  const list = typeof value === "function" ? value(args) : value.flatMap((v) => {
    if (typeof v === "number")
      return args;
    return [v];
  });
  return {
    command: list[0],
    args: list.slice(1)
  };
}

// ../../node_modules/.pnpm/package-manager-detector@0.2.8/node_modules/package-manager-detector/dist/constants.mjs
var AGENTS = [
  "npm",
  "yarn",
  "yarn@berry",
  "pnpm",
  "pnpm@6",
  "bun",
  "deno"
];
var LOCKS = {
  "bun.lock": "bun",
  "bun.lockb": "bun",
  "deno.lock": "deno",
  "pnpm-lock.yaml": "pnpm",
  "yarn.lock": "yarn",
  "package-lock.json": "npm",
  "npm-shrinkwrap.json": "npm"
};

// ../../node_modules/.pnpm/package-manager-detector@0.2.8/node_modules/package-manager-detector/dist/detect.mjs
import fs from "node:fs";
import fsPromises from "node:fs/promises";
import path from "node:path";
import process2 from "node:process";
async function detect(options = {}) {
  const { cwd, onUnknown } = options;
  for (const directory of lookup(cwd)) {
    for (const lock of Object.keys(LOCKS)) {
      if (await fileExists(path.join(directory, lock))) {
        const name = LOCKS[lock];
        const result2 = await parsePackageJson(path.join(directory, "package.json"), onUnknown);
        if (result2)
          return result2;
        else
          return { name, agent: name };
      }
    }
    const result = await parsePackageJson(path.join(directory, "package.json"), onUnknown);
    if (result)
      return result;
  }
  return null;
}
function* lookup(cwd = process2.cwd()) {
  let directory = path.resolve(cwd);
  const { root } = path.parse(directory);
  while (directory && directory !== root) {
    yield directory;
    directory = path.dirname(directory);
  }
}
async function parsePackageJson(filepath, onUnknown) {
  return !filepath || !await fileExists(filepath) ? null : handlePackageManager(filepath, onUnknown);
}
function handlePackageManager(filepath, onUnknown) {
  try {
    const pkg = JSON.parse(fs.readFileSync(filepath, "utf8"));
    let agent;
    if (typeof pkg.packageManager === "string") {
      const [name, ver] = pkg.packageManager.replace(/^\^/, "").split("@");
      let version = ver;
      if (name === "yarn" && Number.parseInt(ver) > 1) {
        agent = "yarn@berry";
        version = "berry";
        return { name, agent, version };
      } else if (name === "pnpm" && Number.parseInt(ver) < 7) {
        agent = "pnpm@6";
        return { name, agent, version };
      } else if (AGENTS.includes(name)) {
        agent = name;
        return { name, agent, version };
      } else {
        return onUnknown?.(pkg.packageManager) ?? null;
      }
    }
  } catch {
  }
  return null;
}
async function fileExists(filePath) {
  try {
    const stats = await fsPromises.stat(filePath);
    if (stats.isFile()) {
      return true;
    }
  } catch {
  }
  return false;
}

// src/utils/platform.ts
var getInstallationCommand = async () => {
  const packageManager = await detect();
  if (!packageManager) {
    throw new Error("No package manager detected");
  }
  const command = resolveCommand(packageManager.agent, "execute", [
    "playwright",
    "install",
    "chromium"
  ]);
  if (!command) {
    throw new Error(
      "Failed to resolve playwright browser installation command"
    );
  }
  return `${command.command} ${command.args.join(" ")}`;
};

// src/browser/manager/index.ts
var BrowserManager = class {
  browser = null;
  context = null;
  config;
  constructor(config) {
    this.config = config;
  }
  normalizeUrl(url) {
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.toString();
    } catch {
      return url;
    }
  }
  async launch() {
    try {
      this.browser = await chromium.launch({
        headless: this.config.headless ?? false
      });
    } catch (error) {
      if (error instanceof Error && error.message.includes("Executable doesn't exist")) {
        console.log(pc3.yellow("Installing Playwright browser..."));
        const installationCommand = await getInstallationCommand();
        execSync(installationCommand, { stdio: "inherit" });
        console.log(pc3.green("\u2713 Playwright browser installed"));
        this.browser = await chromium.launch({
          headless: this.config.headless ?? false
        });
      } else {
        throw error;
      }
    }
    this.context = await this.browser.newContext({
      viewport: { width: 1920, height: 1080 },
      baseURL: this.config.baseUrl
    });
    const page = await this.context.newPage();
    await page.goto(this.normalizeUrl(this.config.baseUrl));
    await page.waitForLoadState("networkidle");
    return this.context;
  }
  async clearContext() {
    if (!this.context) {
      throw new Error("No context available");
    }
    await Promise.all([
      this.context.clearCookies(),
      // Clear storage
      this.context.pages().map(
        (page) => page.evaluate(() => {
          localStorage.clear();
          sessionStorage.clear();
          indexedDB.deleteDatabase("shortest");
        })
      ),
      // Clear permissions
      this.context.clearPermissions()
    ]);
    await Promise.all(
      this.context.pages().map((page) => page.goto("about:blank"))
    );
    const pages = this.context.pages();
    if (pages.length > 1) {
      await Promise.all(pages.slice(1).map((page) => page.close()));
    }
    const baseUrl = this.config.baseUrl;
    await pages[0].goto(baseUrl);
    await pages[0].waitForLoadState("networkidle");
    return this.context;
  }
  async recreateContext() {
    return this.clearContext();
  }
  async closeContext() {
    if (this.context) {
      await this.context.close();
      this.context = null;
    }
  }
  async close() {
    if (this.context) {
      await this.context.close();
      this.context = null;
    }
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }
  getContext() {
    return this.context;
  }
  getBrowser() {
    return this.browser;
  }
};

// src/cache/cache.ts
import * as fs2 from "fs";
import path2 from "path";

// src/utils/crypto.ts
import crypto from "crypto";
function hashData(data) {
  const hash = crypto.createHash("sha256");
  return hash.update(JSON.stringify(data)).digest("hex");
}

// src/utils/logger.ts
import pc4 from "picocolors";
var Logger = class {
  currentFile = "";
  testResults = {};
  startTime = Date.now();
  currentTest = null;
  // token pricing (Claude 3.5 Sonnet)
  COST_PER_1K_INPUT_TOKENS = 3e-3;
  COST_PER_1K_OUTPUT_TOKENS = 0.015;
  initializeTest(test2) {
    const testKey = test2.name || "Unnamed Test";
    this.currentTest = {
      name: testKey,
      status: "pending"
    };
    this.testResults[testKey] = this.currentTest;
  }
  startFile(file) {
    this.currentFile = file;
    console.log("\u{1F4C4}", pc4.blue(pc4.bold(this.currentFile)));
  }
  startTest(test2) {
    console.log(this.getStatusIcon("running"), test2.name);
  }
  endTest(status, error, tokenUsage) {
    if (!this.currentTest) {
      throw new Error("Current test not initialized");
    }
    this.testResults[this.currentTest.name].status = status;
    this.testResults[this.currentTest.name].error = error;
    this.testResults[this.currentTest.name].tokenUsage = tokenUsage;
    const symbol = status === "passed" ? "\u2713" : "\u2717";
    const color = status === "passed" ? pc4.green : pc4.red;
    console.log(`  ${color(`${symbol} ${status}`)}`);
    if (tokenUsage) {
      const totalTokens = tokenUsage.input + tokenUsage.output;
      const cost = this.calculateCost(tokenUsage.input, tokenUsage.output);
      console.log(
        pc4.dim(
          `    \u21B3 ${totalTokens.toLocaleString()} tokens (\u2248 $${cost.toFixed(2)})`
        )
      );
    }
    if (error) {
      this.reportError("Test Execution", error.message);
    }
    this.currentTest = null;
  }
  calculateCost(inputTokens, outputTokens) {
    const inputCost = inputTokens / 1e3 * this.COST_PER_1K_INPUT_TOKENS;
    const outputCost = outputTokens / 1e3 * this.COST_PER_1K_OUTPUT_TOKENS;
    return Number((inputCost + outputCost).toFixed(3));
  }
  calculateTotalTokenUsage() {
    let totalInputTokens = 0;
    let totalOutputTokens = 0;
    Object.values(this.testResults).forEach((result) => {
      if (result.tokenUsage) {
        totalInputTokens += result.tokenUsage.input;
        totalOutputTokens += result.tokenUsage.output;
      }
    });
    const totalCost = this.calculateCost(totalInputTokens, totalOutputTokens);
    return {
      totalInputTokens,
      totalOutputTokens,
      totalCost
    };
  }
  getStatusIcon(status) {
    switch (status) {
      case "pending":
        return pc4.yellow("\u25CB");
      case "running":
        return pc4.blue("\u25CF");
      case "passed":
        return pc4.green("\u2713");
      case "failed":
        return pc4.red("\u2717");
    }
  }
  summary() {
    const duration = ((Date.now() - this.startTime) / 1e3).toFixed(2);
    const totalTests = Object.keys(this.testResults).length;
    const failedTests = Object.values(this.testResults).filter(
      (t) => t.status === "failed"
    ).length;
    const passedTests = totalTests - failedTests;
    const { totalInputTokens, totalOutputTokens, totalCost } = this.calculateTotalTokenUsage();
    const totalTokens = totalInputTokens + totalOutputTokens;
    console.log(pc4.dim("\u23AF".repeat(50)), "\n");
    const LABEL_WIDTH = 15;
    console.log(
      pc4.bold(" Tests".padEnd(LABEL_WIDTH)),
      failedTests ? `${pc4.red(`${failedTests} failed`)} | ${pc4.green(`${passedTests} passed`)}` : pc4.green(`${passedTests} passed`),
      pc4.dim(`(${totalTests})`)
    );
    console.log(
      pc4.bold(" Duration".padEnd(LABEL_WIDTH)),
      pc4.dim(`${duration}s`)
    );
    console.log(
      pc4.bold(" Started at".padEnd(LABEL_WIDTH)),
      pc4.dim(new Date(this.startTime).toLocaleTimeString())
    );
    console.log(
      pc4.bold(" Tokens".padEnd(LABEL_WIDTH)),
      pc4.dim(
        `${totalTokens.toLocaleString()} tokens (\u2248 $${totalCost.toFixed(2)})`
      )
    );
    console.log("\n", pc4.dim("\u23AF".repeat(50)));
  }
  allTestsPassed() {
    return !Object.values(this.testResults).some(
      (test2) => test2.status === "failed"
    );
  }
  reportStatus(message) {
    console.log(pc4.blue(`
${message}`));
  }
  error(context, message) {
    console.error(pc4.red(`
${context} Error: ${message}`));
  }
  reportError(context, message) {
    console.error(pc4.red(`
${context} Error: ${message}`));
  }
  reportAssertion(step, status, error) {
    const icon = status === "passed" ? "\u2713" : "\u2717";
    const color = status === "passed" ? "green" : "red";
    console.log(pc4[color](`${icon} ${step}`));
    if (error && status === "failed") {
      console.log(pc4.red(`  Expected: ${error.matcherResult?.expected}`));
      console.log(pc4.red(`  Received: ${error.matcherResult?.actual}`));
      console.log(pc4.red(`  Message: ${error.message}`));
    }
  }
};

// src/utils/objects.ts
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return mergeDeep(target, ...sources);
}

// src/cache/cache.ts
var BaseCache = class {
  CACHE_TTL = 7 * 24 * 60 * 60 * 1e3;
  // 1 week
  CLEANUP_PROBABILITY = 0.03;
  // 3% chance
  logger;
  cacheFile;
  // Locking (ensures that only one process or thread can access or modify cache)
  lockFile;
  LOCK_TIMEOUT_MS = 1e3;
  lockAcquired = false;
  lockAcquireFailures = 0;
  constructor() {
    this.logger = new Logger();
    this.cacheFile = path2.join(process.cwd(), ".shortest", "cache.json");
    this.lockFile = path2.join(process.cwd(), ".shortest", "cache.lock");
    this.ensureDirectory();
    this.setupProcessHandlers();
  }
  ensureDirectory() {
    if (!fs2.existsSync(path2.dirname(this.cacheFile))) {
      fs2.mkdirSync(path2.dirname(this.cacheFile), { recursive: true });
    }
  }
  read() {
    if (fs2.existsSync(this.cacheFile)) {
      try {
        return JSON.parse(
          fs2.readFileSync(this.cacheFile, "utf-8")
        );
      } catch {
        return {};
      }
    } else {
      return {};
    }
  }
  async get(key) {
    if (!await this.acquireLock()) {
      this.logger.error("Cache", "Failed to acquire lock for set operation");
      return null;
    }
    try {
      const hashedKey = hashData(key);
      const cache = this.read();
      return cache[hashedKey] ?? null;
    } catch {
      this.logger.error("Cache", "Failed to get");
      return null;
    } finally {
      this.releaseLock();
    }
  }
  async set(key, value) {
    if (!await this.acquireLock()) {
      this.logger.error("Cache", "Failed to acquire lock for set operation");
      return;
    }
    try {
      const hashedKey = hashData(key);
      const cache = this.read();
      if (!cache[hashedKey]) {
        cache[hashedKey] = { data: {} };
      }
      cache[hashedKey].data = mergeDeep(cache[hashedKey].data, {
        ...value,
        timestamp: Date.now()
      });
      this.write(cache);
    } catch {
      this.logger.error("Cache", "Failed to set");
      this.reset();
    } finally {
      this.releaseLock();
      if (Math.random() < this.CLEANUP_PROBABILITY) {
        this.cleanup();
      }
    }
  }
  reset() {
    try {
      fs2.writeFileSync(this.cacheFile, "{}");
    } catch {
      this.logger.error("Cache", "Failed to reset");
    } finally {
      this.releaseLock();
    }
  }
  write(cache) {
    try {
      fs2.writeFileSync(this.cacheFile, JSON.stringify(cache, null, 2));
    } catch {
      this.logger.error("Cache", "Failed to write");
    }
  }
  async delete(key) {
    if (!await this.acquireLock()) {
      this.logger.error("Cache", "Failed to acquire lock for delete operation");
      return;
    }
    try {
      const hashedKey = hashData(key);
      const cache = this.read();
      if (cache[hashedKey]) {
        delete cache[hashedKey];
        this.write(cache);
      } else {
        this.logger.error("Cache", "Failed to delete: entry not found");
      }
    } catch {
      this.logger.error("Cache", "Failed to delete");
    }
  }
  cleanup() {
    try {
      const cache = this.read();
      let cacheModified = false;
      for (const [key, value] of Object.entries(cache)) {
        if (value) {
          if (Date.now() - value.timestamp > this.CACHE_TTL) {
            delete cache[key];
            cacheModified = true;
          }
        }
      }
      if (cacheModified) {
        this.write(cache);
      }
    } catch {
      this.logger.error("Cache", "Failed to cleanup");
    }
  }
  async acquireLock() {
    const startTime = Date.now();
    while (Date.now() - startTime < this.LOCK_TIMEOUT_MS) {
      try {
        if (fs2.existsSync(this.lockFile)) {
          const lockAge = Date.now() - fs2.statSync(this.lockFile).mtimeMs;
          if (lockAge > this.LOCK_TIMEOUT_MS) {
            fs2.unlinkSync(this.lockFile);
          }
        }
        fs2.writeFileSync(this.lockFile, process.pid.toString(), { flag: "wx" });
        this.lockAcquireFailures = 0;
        this.lockAcquired = true;
        return true;
      } catch {
        this.logger.error("Cache", "Failed to acquire lock");
        await new Promise((resolve2) => setTimeout(resolve2, 5));
      }
    }
    this.logger.error("Cache", "Failed to acquire lock after timeout");
    this.lockAcquireFailures++;
    if (this.lockAcquireFailures >= 3) {
      this.logger.error(
        "Cache",
        "Failed to acquire lock 3 times in a row. Releasing lock manually."
      );
      this.releaseLock();
    }
    return false;
  }
  releaseLock() {
    try {
      if (fs2.existsSync(this.lockFile)) {
        fs2.unlinkSync(this.lockFile);
      }
      this.lockAcquired = false;
    } catch {
      this.logger.error("Cache", "Failed to release lock");
    }
  }
  setupProcessHandlers() {
    const releaseLockAndExit = () => {
      this.releaseLock();
      process.exit();
    };
    process.on("exit", releaseLockAndExit);
    process.on("SIGINT", releaseLockAndExit);
    process.on("SIGTERM", releaseLockAndExit);
    process.on("uncaughtException", (err) => {
      this.logger.error("Cache", err.message);
      if (this.lockAcquired) {
        releaseLockAndExit();
      }
    });
  }
};

// src/core/runner/index.ts
var TestRunner = class {
  config;
  cwd;
  exitOnSuccess;
  forceHeadless;
  targetUrl;
  compiler;
  browserManager;
  logger;
  debugAI;
  noCache;
  testContext = null;
  cache;
  constructor(cwd, exitOnSuccess = true, forceHeadless = false, targetUrl, debugAI = false, noCache = false) {
    this.cwd = cwd;
    this.exitOnSuccess = exitOnSuccess;
    this.forceHeadless = forceHeadless;
    this.targetUrl = targetUrl;
    this.debugAI = debugAI;
    this.noCache = noCache;
    this.compiler = new TestCompiler();
    this.logger = new Logger();
    this.cache = new BaseCache();
  }
  async initialize() {
    await initialize();
    this.config = getConfig();
    if (this.forceHeadless) {
      this.config = {
        ...this.config,
        headless: true
      };
    }
    if (this.targetUrl) {
      this.config = {
        ...this.config,
        baseUrl: this.targetUrl
      };
    }
    this.browserManager = new BrowserManager(this.config);
  }
  async findTestFiles(pattern) {
    const testPattern = pattern || this.config.testPattern || "**/*.test.ts";
    const files = await glob(testPattern, {
      cwd: this.cwd,
      absolute: true
    });
    if (files.length === 0) {
      this.logger.error(
        "Test Discovery",
        `No test files found matching: ${testPattern}`
      );
      process.exit(1);
    }
    return files;
  }
  async createTestContext(context) {
    if (!this.testContext) {
      const playwrightObj = {
        ...playwright,
        request: {
          ...request,
          newContext: async (options) => {
            const requestContext = await request.newContext({
              baseURL: this.config.baseUrl,
              ...options
            });
            return requestContext;
          }
        }
      };
      this.testContext = {
        page: context.pages()[0],
        browser: this.browserManager.getBrowser(),
        playwright: playwrightObj
      };
    }
    return this.testContext;
  }
  async executeTest(test2, context, config = { noCache: false }) {
    if (test2.directExecution) {
      try {
        const testContext2 = await this.createTestContext(context);
        await test2.fn?.(testContext2);
        return {
          result: "pass",
          reason: "Direct execution successful",
          tokenUsage: { input: 0, output: 0 }
        };
      } catch (error) {
        return {
          result: "fail",
          reason: error instanceof Error ? error.message : "Direct execution failed",
          tokenUsage: { input: 0, output: 0 }
        };
      }
    }
    const testContext = await this.createTestContext(context);
    const browserTool = new BrowserTool(testContext.page, this.browserManager, {
      width: 1920,
      height: 1080,
      testContext: {
        ...testContext,
        currentTest: test2,
        currentStepIndex: 0
      }
    });
    if (!this.config.anthropicKey) {
      return {
        result: "fail",
        reason: "ANTHROPIC_KEY is not set",
        tokenUsage: { input: 0, output: 0 }
      };
    }
    const aiClient = new AIClient(
      {
        apiKey: this.config.anthropicKey,
        model: "claude-3-5-sonnet-20241022",
        maxMessages: 10,
        debug: this.debugAI
      },
      this.debugAI
    );
    const initialState = await browserTool.execute({
      action: "screenshot"
    });
    const prompt = [
      `Test: "${test2.name}"`,
      test2.payload ? `Context: ${JSON.stringify(test2.payload)}` : "",
      `Callback function: ${test2.fn ? " [HAS_CALLBACK]" : " [NO_CALLBACK]"}`,
      // Add expectations if they exist
      ...test2.expectations?.length ? [
        "\nExpect:",
        ...test2.expectations.map(
          (exp, i) => `${i + 1}. ${exp.description}${exp.fn ? " [HAS_CALLBACK]" : "[NO_CALLBACK]"}`
        )
      ] : ["\nExpect:", `1. "${test2.name}" expected to be successful`],
      "\nCurrent Page State:",
      `URL: ${initialState.metadata?.window_info?.url || "unknown"}`,
      `Title: ${initialState.metadata?.window_info?.title || "unknown"}`
    ].filter(Boolean).join("\n");
    if (!this.noCache && !config.noCache) {
      if (await this.cache.get(test2)) {
        try {
          const result2 = await this.runCachedTest(test2, browserTool);
          if (test2.afterFn) {
            try {
              await test2.afterFn(testContext);
            } catch (error) {
              return {
                result: "fail",
                reason: result2?.result === "fail" ? `AI: ${result2.reason}, After: ${error instanceof Error ? error.message : String(error)}` : error instanceof Error ? error.message : String(error),
                tokenUsage: { input: 0, output: 0 }
              };
            }
          }
          return { ...result2, tokenUsage: { input: 0, output: 0 } };
        } catch {
          await this.cache.delete(test2);
          const page = browserTool.getPage();
          await page.goto(initialState.metadata?.window_info?.url);
          await this.executeTest(test2, context, {
            noCache: true
          });
        }
      }
    }
    if (test2.beforeFn) {
      try {
        await test2.beforeFn(testContext);
      } catch (error) {
        return {
          result: "fail",
          reason: error instanceof Error ? error.message : String(error),
          tokenUsage: { input: 0, output: 0 }
        };
      }
    }
    const result = await aiClient.processAction(prompt, browserTool);
    if (!result) {
      throw new Error("AI processing failed: no result returned");
    }
    const finalMessage = result.finalResponse.content.find(
      (block) => block.type === "text" && block.text.includes(
        '"result":'
      )
    );
    if (!finalMessage || finalMessage.type !== "text") {
      throw new Error("No test result found in AI response");
    }
    const jsonMatch = finalMessage.text.match(/{[\s\S]*}/);
    if (!jsonMatch) {
      throw new Error("Invalid test result format");
    }
    const aiResult = JSON.parse(jsonMatch[0]);
    if (test2.afterFn) {
      try {
        await test2.afterFn(testContext);
      } catch (error) {
        return {
          result: "fail",
          reason: aiResult.result === "fail" ? `AI: ${aiResult.reason}, After: ${error instanceof Error ? error.message : String(error)}` : error instanceof Error ? error.message : String(error),
          tokenUsage: result.tokenUsage
        };
      }
    }
    if (aiResult.result === "pass") {
      await this.cache.set(test2, result.pendingCache);
    }
    return { ...aiResult, tokenUsage: result.tokenUsage };
  }
  async executeTestFile(file) {
    try {
      const registry = global.__shortest__.registry;
      registry.tests.clear();
      registry.currentFileTests = [];
      const filePathWithoutCwd = file.replace(this.cwd + "/", "");
      this.logger.startFile(filePathWithoutCwd);
      const compiledPath = await this.compiler.compileFile(file);
      await import(pathToFileURL(compiledPath).href);
      const context = await this.browserManager.launch();
      const testContext = await this.createTestContext(context);
      try {
        for (const hook of registry.beforeAllFns) {
          await hook(testContext);
        }
        for (const test2 of registry.currentFileTests) {
          for (const hook of registry.beforeEachFns) {
            await hook(testContext);
          }
          this.logger.initializeTest(test2);
          this.logger.startTest(test2);
          const result = await this.executeTest(test2, context);
          this.logger.endTest(
            result.result === "pass" ? "passed" : "failed",
            result.result === "fail" ? new Error(result.reason) : void 0,
            result.tokenUsage
          );
          for (const hook of registry.afterEachFns) {
            await hook(testContext);
          }
        }
        for (const hook of registry.afterAllFns) {
          await hook(testContext);
        }
      } finally {
        await this.browserManager.close();
        this.testContext = null;
        registry.beforeAllFns = [];
        registry.afterAllFns = [];
        registry.beforeEachFns = [];
        registry.afterEachFns = [];
      }
    } catch (error) {
      this.testContext = null;
      if (error instanceof Error) {
        this.logger.endTest("failed", error);
      }
    }
  }
  async runTests(pattern) {
    await this.initialize();
    const files = await this.findTestFiles(pattern);
    if (files.length === 0) {
      this.logger.error(
        "Test Discovery",
        `No test files found matching the pattern: ${pattern || this.config.testPattern}`
      );
      process.exit(1);
    }
    for (const file of files) {
      await this.executeTestFile(file);
    }
    this.logger.summary();
    if (this.exitOnSuccess && this.logger.allTestsPassed()) {
      process.exit(0);
    } else {
      process.exit(1);
    }
  }
  async runCachedTest(test2, browserTool) {
    const cachedTest = await this.cache.get(test2);
    if (this.debugAI) {
      console.log(pc5.green(`  Executing cached test ${hashData(test2)}`));
    }
    const steps = cachedTest?.data.steps?.filter(
      (step) => step.action?.input.action !== "screenshot" /* Screenshot */.toString()
    );
    if (!steps) {
      return {
        result: "fail",
        reason: "No steps to execute, running test in normal mode",
        tokenUsage: { input: 0, output: 0 }
      };
    }
    for (const step of steps) {
      await new Promise((resolve2) => setTimeout(resolve2, 1e3));
      if (step.action?.input.action === "mouse_move" /* MouseMove */ && // @ts-expect-error Interface and actual values differ
      step.action.input.coordinate) {
        const [x, y] = step.action.input.coordinate;
        const componentStr = await browserTool.getNormalizedComponentStringByCoords(x, y);
        if (componentStr !== step.extras.componentStr) {
          return {
            result: "fail",
            reason: "Component UI elements are different, running test in normal mode",
            tokenUsage: { input: 0, output: 0 }
          };
        }
      }
      if (step.action?.input) {
        try {
          await browserTool.execute(step.action.input);
        } catch (error) {
          console.error(
            `Failed to execute step with input ${step.action.input}`,
            error
          );
        }
      }
    }
    return {
      result: "pass",
      reason: "All actions successfully replayed from cache"
    };
  }
};

// src/cli/bin.ts
process.removeAllListeners("warning");
process.on("warning", (warning) => {
  if (warning.name === "DeprecationWarning" && warning.message.includes("punycode")) {
    return;
  }
  console.warn(warning);
});
var VALID_FLAGS = [
  "--headless",
  "--github-code",
  "--debug-ai",
  "--help",
  "--no-cache",
  "-h"
];
var VALID_PARAMS = ["--target", "--secret"];
function showHelp() {
  console.log(`
${pc6.bold("Shortest")} - AI-powered end-to-end testing framework
${pc6.dim("https://github.com/anti-work/shortest")}

${pc6.bold("Usage:")}
  shortest [options] [test-pattern]

${pc6.bold("Options:")}
  --headless          Run tests in headless browser mode
  --debug-ai          Show AI conversation and decision process
  --target=<url>      Set target URL for tests (default: http://localhost:3000)
  --github-code       Generate GitHub 2FA code for authentication
  --no-cache          Disable caching (storing browser actions between tests)

${pc6.bold("Authentication:")}
  --secret=<key>      GitHub TOTP secret key (or use .env.local)

${pc6.bold("Examples:")}
  ${pc6.dim("# Run all tests")}
  shortest

  ${pc6.dim("# Run specific test file")}
  shortest login.test.ts

  ${pc6.dim("# Run tests in headless mode")}
  shortest --headless

  ${pc6.dim("# Generate GitHub 2FA code")}
  shortest --github-code --secret=<OTP_SECRET>

${pc6.bold("Environment Setup:")}
  Required variables in .env.local:
  - ANTHROPIC_API_KEY     Required for AI test execution
  - GITHUB_TOTP_SECRET    Required for GitHub authentication
  - GITHUB_USERNAME       GitHub login credentials
  - GITHUB_PASSWORD       GitHub login credentials

${pc6.bold("Documentation:")}
  Visit ${pc6.cyan(
    "https://github.com/anti-work/shortest"
  )} for detailed setup and usage
`);
}
async function handleGitHubCode(args) {
  try {
    const secret = args.find((arg) => arg.startsWith("--secret="))?.split("=")[1];
    const github = new GitHubTool(secret);
    const { code, timeRemaining } = github.generateTOTPCode();
    console.log("\n" + pc6.bgCyan(pc6.black(" GitHub 2FA Code ")));
    console.log(pc6.cyan("Code: ") + pc6.bold(code));
    console.log(pc6.cyan("Expires in: ") + pc6.bold(`${timeRemaining}s`));
    console.log(
      pc6.dim(`Using secret from: ${secret ? "CLI flag" : ".env file"}
`)
    );
    process.exit(0);
  } catch (error) {
    console.error(pc6.red("\n\u2716 Error:"), error.message, "\n");
    process.exit(1);
  }
}
function isValidArg(arg) {
  if (VALID_FLAGS.includes(arg)) {
    return true;
  }
  const paramName = arg.split("=")[0];
  if (VALID_PARAMS.includes(paramName)) {
    return true;
  }
  return false;
}
async function main() {
  const args = process.argv.slice(2);
  if (args.includes("--help") || args.includes("-h")) {
    showHelp();
    process.exit(0);
  }
  if (args.includes("--github-code")) {
    await handleGitHubCode(args);
  }
  const invalidFlags = args.filter((arg) => arg.startsWith("--")).filter((arg) => !isValidArg(arg));
  if (invalidFlags.length > 0) {
    console.error(`Error: Invalid argument(s): ${invalidFlags.join(", ")}`);
    process.exit(1);
  }
  const headless = args.includes("--headless");
  const targetUrl = args.find((arg) => arg.startsWith("--target="))?.split("=")[1];
  const cliTestPattern = args.find((arg) => !arg.startsWith("--"));
  const debugAI = args.includes("--debug-ai");
  const noCache = args.includes("--no-cache");
  try {
    const runner = new TestRunner(
      process.cwd(),
      true,
      headless,
      targetUrl,
      debugAI,
      noCache
    );
    await runner.initialize();
    const config = getConfig();
    const testPattern = cliTestPattern || config.testPattern;
    await runner.runTests(testPattern);
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes("Config")) {
        console.error(pc6.red("\nConfiguration Error:"));
        console.error(pc6.dim(error.message));
        console.error(
          pc6.dim(
            "\nMake sure you have a valid shortest.config.ts with all required fields:"
          )
        );
        console.error(pc6.dim("  - headless: boolean"));
        console.error(pc6.dim("  - baseUrl: string"));
        console.error(pc6.dim("  - testPattern: string"));
        console.error(pc6.dim("  - anthropicKey: string"));
        console.error();
      } else {
        console.error(pc6.red("\nError:"), error.message);
      }
    } else {
      console.error(pc6.red("\nUnknown error occurred"));
    }
    process.exit(1);
  }
}
main().catch((error) => {
  console.error(error);
  process.exit(1);
});
