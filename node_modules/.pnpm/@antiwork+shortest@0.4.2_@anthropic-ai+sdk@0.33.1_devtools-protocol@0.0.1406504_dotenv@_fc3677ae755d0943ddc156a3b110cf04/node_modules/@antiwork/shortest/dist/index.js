// src/index.ts
import { join as join2 } from "path";
import dotenv from "dotenv";
import { expect as jestExpect } from "expect";

// src/browser/core/api-request.ts
function generatePrompt(request, config) {
  return `
        You are about to process an API request. Your goal is to dynamically populate variables (like <Bearer API KEY>) with actual values, either inferred or retrieved. Follow these steps:
        - Analyze the REQUEST OBJECT: extract all necessary values (e.g., HTTP method, headers, authorization tokens).
        - Use the CONFIG OBJECT for the base URL, timeout, headers, storageState (used for cookies) or other reusable settings.
        - Assemble the final bashh command using these values and return it as a clean, actionable string.
          Your output should look like a ready-to-execute bash command with no extraneous text.
        - Ensure the bash command uses the appropriate HTTP request package for the operating system:
          - For Linux/macOS, use 'cURL'.
          - For Windows, use 'PowerShell'.
        - Reference to SYSTEM_PROMPT 'Bash Commands' section for additional context on the task.

        REQUEST OBJECT (RequestInit dictionary of the Fetch API): ${JSON.stringify(request)}
        CONFIG OBJECT: ${JSON.stringify(config)}
        IMPORTANT:
          - You MUST NOT modify or process the response data in any way (e.g., jq, grep, or any other way of modifying the original data)/
            Your SOLE responsibility is to create a clean, unmodified bash command for execution.
          - Every single field in the config object MUST be accounted for in the final bash command.
          - DO NOT add any extra flags or arguments or flags unless they are explicitly state in REQUEST OBJECT or CONFIG OBJECT.
        `;
}
var APIRequest = class {
  config;
  constructor(config = {}) {
    this.config = config;
  }
  fetch(requestBase, config) {
    const request = this.processRequest(requestBase);
    return generatePrompt(request, { ...this.config, ...config });
  }
  processRequest(request) {
    if (request.params instanceof URLSearchParams) {
      request.params = request.params.toString();
    }
    return request;
  }
};

// src/core/compiler/index.ts
import { mkdirSync, existsSync, writeFileSync } from "fs";
import { tmpdir } from "os";
import { join, resolve, basename } from "path";
import { build } from "esbuild";
var TestCompiler = class {
  cacheDir;
  defaultOptions = {
    format: "esm",
    platform: "node",
    target: "node18",
    sourcemap: true,
    bundle: true,
    external: [
      "shortest",
      "fs",
      "path",
      "os",
      "util",
      "events",
      "stream",
      "assert",
      "url",
      "crypto",
      "buffer",
      "querystring",
      "fsevents"
    ],
    banner: {
      js: `
        import { fileURLToPath } from 'url';
        import { dirname } from 'path';
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = dirname(__filename);
        import { createRequire } from "module";
        const require = createRequire(import.meta.url);
      `
    }
  };
  constructor() {
    this.cacheDir = join(tmpdir(), "shortest-cache");
    if (!existsSync(this.cacheDir)) {
      mkdirSync(this.cacheDir, { recursive: true });
    }
  }
  async compileFile(filePath) {
    const fileName = basename(filePath).replace(".ts", ".mjs");
    const outputPath = join(this.cacheDir, fileName);
    const packageJson = {
      type: "module",
      imports: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      }
    };
    writeFileSync(
      join(this.cacheDir, "package.json"),
      JSON.stringify(packageJson)
    );
    await build({
      ...this.defaultOptions,
      entryPoints: [filePath],
      outfile: outputPath,
      alias: {
        shortest: resolve(process.cwd(), "packages/shortest/src/index.ts")
      },
      resolveExtensions: [".ts", ".js", ".mjs"],
      banner: {
        js: 'import { createRequire } from "module";const require = createRequire(import.meta.url);'
      }
    });
    return outputPath;
  }
  async loadModule(filePath, cwd) {
    const absolutePath = resolve(cwd, filePath);
    if (!existsSync(absolutePath)) {
      throw new Error(`Config file not found: ${filePath}`);
    }
    try {
      const result = await build({
        ...this.defaultOptions,
        entryPoints: [absolutePath],
        write: false,
        external: ["shortest"]
      });
      const code = result.outputFiles[0].text;
      const tempFile = join(this.cacheDir, "config.mjs");
      writeFileSync(tempFile, code);
      return import(`file://${tempFile}`);
    } catch (error) {
      throw new Error(`Failed to load config from ${absolutePath}: ${error}`);
    }
  }
};

// src/index.ts
var globalConfig = null;
var compiler = new TestCompiler();
if (!global.__shortest__) {
  global.__shortest__ = {
    expect: jestExpect,
    registry: {
      tests: /* @__PURE__ */ new Map(),
      currentFileTests: [],
      beforeAllFns: [],
      afterAllFns: [],
      beforeEachFns: [],
      afterEachFns: [],
      directTestCounter: 0
    }
  };
  global.expect = global.__shortest__.expect;
  dotenv.config({ path: join2(process.cwd(), ".env") });
  dotenv.config({ path: join2(process.cwd(), ".env.local") });
}
function validateConfig(config) {
  const missingFields = [];
  if (config.headless === void 0)
    missingFields.push("headless");
  if (!config.baseUrl)
    missingFields.push("baseUrl");
  if (!config.testPattern)
    missingFields.push("testPattern");
  if (!config.anthropicKey && !process.env.ANTHROPIC_API_KEY)
    missingFields.push("anthropicKey");
  if (missingFields.length > 0) {
    throw new Error(
      `Missing required fields in shortest.config.ts:
` + missingFields.map((field) => `  - ${field}`).join("\n")
    );
  }
}
async function initialize() {
  if (globalConfig)
    return globalConfig;
  dotenv.config({ path: join2(process.cwd(), ".env") });
  dotenv.config({ path: join2(process.cwd(), ".env.local") });
  const configFiles = [
    "shortest.config.ts",
    "shortest.config.js",
    "shortest.config.mjs"
  ];
  for (const file of configFiles) {
    try {
      const module = await compiler.loadModule(file, process.cwd());
      if (module.default) {
        const config = module.default;
        validateConfig(config);
        globalConfig = {
          ...config,
          anthropicKey: process.env.ANTHROPIC_API_KEY || config.anthropicKey
        };
        return globalConfig;
      }
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Config Error: ${error.message}`);
      }
      continue;
    }
  }
  throw new Error(
    "No config file found. Create shortest.config.ts in your project root.\nRequired fields:\n  - headless: boolean\n  - baseUrl: string\n  - testPattern: string\n  - anthropicKey: string"
  );
}
function getConfig() {
  if (!globalConfig) {
    throw new Error("Config not initialized. Call initialize() first");
  }
  return globalConfig;
}
function createTestChain(nameOrFn, payloadOrFn, fn) {
  const registry = global.__shortest__.registry;
  if (Array.isArray(nameOrFn)) {
    const tests = nameOrFn.map((name) => {
      const test3 = {
        name,
        expectations: []
      };
      registry.tests.set(name, [...registry.tests.get(name) || [], test3]);
      registry.currentFileTests.push(test3);
      return test3;
    });
    const lastTest = tests[tests.length - 1];
    if (!lastTest.name) {
      throw new Error("Test name is required");
    }
    return createTestChain(lastTest.name, payloadOrFn, fn);
  }
  if (typeof nameOrFn === "function") {
    registry.directTestCounter++;
    const test3 = {
      name: `Direct Test #${registry.directTestCounter}`,
      directExecution: true,
      fn: nameOrFn
    };
    registry.currentFileTests.push(test3);
    return {
      expect: () => {
        throw new Error("expect() cannot be called on direct execution test");
      },
      after: () => {
        throw new Error("after() cannot be called on direct execution test");
      },
      before: () => {
        throw new Error("before() cannot be called on direct execution test");
      }
    };
  }
  const test2 = {
    name: nameOrFn,
    payload: typeof payloadOrFn === "function" ? void 0 : payloadOrFn,
    fn: typeof payloadOrFn === "function" ? payloadOrFn : fn,
    expectations: []
  };
  registry.tests.set(nameOrFn, [...registry.tests.get(nameOrFn) || [], test2]);
  registry.currentFileTests.push(test2);
  const chain = {
    expect(descriptionOrFn, payloadOrFn2, fn2) {
      if (typeof descriptionOrFn === "function") {
        test2.expectations = test2.expectations || [];
        test2.expectations.push({
          directExecution: true,
          fn: descriptionOrFn
        });
        return chain;
      }
      test2.expectations = test2.expectations || [];
      test2.expectations.push({
        description: descriptionOrFn,
        payload: typeof payloadOrFn2 === "function" ? void 0 : payloadOrFn2,
        fn: typeof payloadOrFn2 === "function" ? payloadOrFn2 : fn2
      });
      return chain;
    },
    before(fn2) {
      test2.beforeFn = (context) => Promise.resolve(fn2(context));
      return chain;
    },
    after(fn2) {
      test2.afterFn = (context) => Promise.resolve(fn2(context));
      return chain;
    }
  };
  return chain;
}
var test = Object.assign(
  (nameOrFn, payloadOrFn, fn) => createTestChain(nameOrFn, payloadOrFn, fn),
  {
    beforeAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeAllFns.push(hook);
    },
    afterAll: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterAllFns.push(hook);
    },
    beforeEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.beforeEachFns.push(hook);
    },
    afterEach: (nameOrFn) => {
      const hook = typeof nameOrFn === "function" ? nameOrFn : void 0;
      if (hook)
        global.__shortest__.registry.afterEachFns.push(hook);
    }
  }
);
var shortest = test;
export {
  APIRequest,
  getConfig,
  initialize,
  shortest,
  test
};
